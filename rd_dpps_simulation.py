"""
Polydisperse Hard-Sphere Colloid Simulation with Reaction-Diffusion
====================================================================

Fast particle-resolved simulations of polydisperse hard-sphere colloids in a 2D domain.
The biochemical signal is generated by solving reaction-diffusion equations for Turing 
patterns (Brusselator model). Particles are driven by diffusiophoresis and Brownian 
dynamics, while also undergoing hard-sphere interactions.

Translated from Fortran to Python by Claude
Original code by Siamak Mirfendereski
"""

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
from typing import Tuple, Optional
import time

# Import sub-modules
from reaction_diffusion import ReactionDiffusionSolver
from advection_diffusion import AdvectionDiffusionSolver
from particle_dynamics import ParticleSystem
from velocity_calculator import VelocityCalculator
from utils import save_data, load_checkpoint, create_output_directory


class PolyDispDPBrownianSimulation:
    """
    Main simulation class for polydisperse diffusiophoretic particles
    with Brownian motion under reaction-diffusion Turing patterns.
    """
    
    def __init__(
        self,
        # Particle parameters
        N: int = 180000,
        N1: int = 90000,  # Number of type-1 particles
        
        # Domain parameters
        size_x: float = 32.0,
        size_y: float = 32.0,
        box_scale: float = 53.08,
        
        # Time parameters
        delta_t: float = 0.05,
        t_final: float = 2000.0,
        
        # Reaction-diffusion parameters
        nx_rd: int = 640,
        ny_rd: int = 640,
        dt_rd: float = 0.00003,
        max_step_rd: int = 6800000,
        A_rd: float = 4.5,
        mu: float = 0.04,
        D_rd: float = 8.0,
        Da_c: float = 1.0,
        am_noise: float = 0.02,
        tol_rd: float = 1e-12,
        
        # Diffusiophoresis mobility parameters
        Mob_C1: float = 0.1,
        Mob_C2: float = -0.1,
        Mob2_C1: float = -0.1,
        Mob2_C2: float = 0.1,
        
        # Advection-diffusion parameters
        maxc_step: int = 3200000,
        tol_ad: float = 1e-10,
        dt_ad: float = 0.000005,
        
        # Physical parameters
        Pe: float = 20.0,  # Peclet number
        
        # Particle size parameters
        mid_p_size: float = 1.0,
        mid_p_size2: float = 1.0,
        low_p_size: float = 0.5,
        low_p_size2: float = 0.5,
        
        # Subcell grid size
        sub_g_size: float = 9.0,
        
        # Output parameters
        output_dir: str = "output",
        save_interval: int = 60
    ):
        """Initialize the simulation with given parameters."""
        
        # Store parameters
        self.N = N
        self.N1 = N1
        self.N2 = N - N1
        
        # Spatial domain
        self.size_x = size_x
        self.size_y = size_y
        self.box = np.array([size_x * box_scale, size_x * box_scale, 2.5])
        
        # Time parameters
        self.delta_t = delta_t
        self.t_final = t_final
        self.M = int(t_final / delta_t)  # Total time steps
        
        # Reaction-diffusion grid
        self.nx_rd = nx_rd
        self.ny_rd = ny_rd
        self.dt_rd = dt_rd
        self.max_step_rd = max_step_rd
        
        # RD parameters
        self.A_rd = A_rd
        self.mu = mu
        self.D_rd = D_rd
        self.Da_c = Da_c
        self.am_noise = am_noise
        self.tol_rd = tol_rd
        
        # Calculate derived parameters
        self.eta = 1.0 / np.sqrt(D_rd)
        Bc = (1 + A_rd * self.eta) ** 2
        self.B_rd = Bc * (1 + mu)
        
        # Mobility parameters
        self.Mob_C1 = Mob_C1
        self.Mob_C2 = Mob_C2
        self.Mob2_C1 = Mob2_C1
        self.Mob2_C2 = Mob2_C2
        
        # Advection-diffusion parameters
        self.maxc_step = maxc_step
        self.tol_ad = tol_ad
        self.dt_ad = dt_ad
        
        # Peclet number
        self.Pe = Pe
        
        # Particle size parameters
        self.mid_p_size = mid_p_size
        self.mid_p_size2 = mid_p_size2
        self.low_p_size = low_p_size
        self.low_p_size2 = low_p_size2
        
        # Subcell parameters
        self.sub_g_size = sub_g_size
        
        # Output parameters
        self.output_dir = Path(output_dir)
        self.save_interval = save_interval
        create_output_directory(self.output_dir)
        
        # Initialize arrays
        self._initialize_arrays()
        
        # Initialize sub-modules
        self.rd_solver = ReactionDiffusionSolver(
            nx_rd, ny_rd, size_x, size_y, dt_rd, max_step_rd,
            tol_rd, A_rd, D_rd, mu, Da_c, am_noise
        )
        
        self.ad_solver = AdvectionDiffusionSolver(
            nx_rd, ny_rd, size_x, size_y, dt_ad, maxc_step, tol_ad
        )
        
        self.particle_system = ParticleSystem(
            N, self.box, sub_g_size
        )
        
        self.velocity_calc = VelocityCalculator(
            N, N1, self.box, Pe, self.eta, self.A_rd
        )
        
        # Scaling factor
        self.a_L0 = size_x / self.box[0]
        
        print("=" * 60)
        print("Discrete particle simulation of finite size spheres")
        print("dispersed in 2D domain driven by Brownian motion &")
        print("diffusiophoresis under concentration gradient of")
        print("solute species")
        print("                    +")
        print("FDM simulation for reaction diffusion of two types of")
        print("solutes (morphogens) using Brusselator reaction model")
        print("FDM for continuum representation of colloidal species")
        print("                  Python translation")
        print("=" * 60)
        print(f"Number of particles = {N}")
        print(f"Number of particles (type 1) = {N1}")
        print(f"Number of particles (type 2) = {self.N2}")
        print(f"Number of time steps = {self.M}")
        print(f"Time step = {delta_t:.3e}")
        print(f"Pe = {Pe:.5e}")
        print(f"Mu = {mu:.5e}")
        print(f"A = {A_rd:.5e}")
        print(f"Dc = {D_rd:.5e}")
        print(f"RD Box size = {size_x:.5e} x {size_y:.5e}")
        print(f"Mobility Colloid 1 = {Mob_C1}, {Mob_C2}")
        print(f"Mobility Colloid 2 = {Mob2_C1}, {Mob2_C2}")
        print(f"Particle radius/l_0 = {self.a_L0:.5e}")
        
    def _initialize_arrays(self):
        """Initialize all arrays for particle positions, velocities, etc."""
        # Particle positions
        self.x = np.zeros(self.N)
        self.y = np.zeros(self.N)
        self.z = np.zeros(self.N)
        
        # Old positions (for time stepping)
        self.xold = np.zeros(self.N)
        self.yold = np.zeros(self.N)
        self.zold = np.zeros(self.N)
        
        # Original positions (for mean-square displacement)
        self.xorig = np.zeros((self.N, 2))
        self.yorig = np.zeros((self.N, 2))
        self.zorig = np.zeros((self.N, 2))
        
        # Particle velocities (2 time levels for Adams-Bashforth)
        self.ux = np.zeros((self.N, 2))
        self.uy = np.zeros((self.N, 2))
        self.uz = np.zeros((self.N, 2))
        
        # Particle sizes (polydisperse)
        self.size_particle = np.ones(self.N)
        
        # Concentration fields (nx_rd+1 x ny_rd+1)
        self.C1 = np.zeros((self.nx_rd + 1, self.ny_rd + 1))
        self.C2 = np.zeros((self.nx_rd + 1, self.ny_rd + 1))
        
        # Concentration gradients (nx_rd+2 x ny_rd+2 for boundary conditions)
        self.Dx_C1 = np.zeros((self.nx_rd + 2, self.ny_rd + 2))
        self.Dx_C2 = np.zeros((self.nx_rd + 2, self.ny_rd + 2))
        self.Dy_C1 = np.zeros((self.nx_rd + 2, self.ny_rd + 2))
        self.Dy_C2 = np.zeros((self.nx_rd + 2, self.ny_rd + 2))
        
        # Colloidal volume fractions
        self.phi1 = np.zeros((self.nx_rd + 1, self.ny_rd + 1))
        self.phi2 = np.zeros((self.nx_rd + 1, self.ny_rd + 1))
        
        # Mean-square displacements
        self.ms = np.zeros((3, self.M + 1))
        
        # Velocity autocorrelation
        self.auto_vel = np.zeros((3, self.M + 1))
        
        # Trajectory of particle 1
        self.p1x = np.zeros(self.M + 1)
        self.p1y = np.zeros(self.M + 1)
        
    def assign_particle_sizes(self):
        """Assign polydisperse sizes to particles."""
        # Type 1 particles (first N1)
        if self.N1 > 0:
            # First half: random between low and mid size
            n1_half = self.N1 // 2
            self.size_particle[:n1_half] = (
                np.random.uniform(0, 1, n1_half) * 
                (self.mid_p_size - self.low_p_size) + 
                self.low_p_size
            )
            
            # Calculate high size to maintain average area
            area_sum_1 = np.sum(self.size_particle[:n1_half] ** 2)
            high_p_size = (
                2.0 * np.sqrt((self.N1 - area_sum_1) / (self.N1 - n1_half)) - 
                self.mid_p_size
            )
            
            # Second half: random between mid and high size
            self.size_particle[n1_half:self.N1] = (
                np.random.uniform(0, 1, self.N1 - n1_half) * 
                (high_p_size - self.mid_p_size) + 
                self.mid_p_size
            )
        
        # Type 2 particles (remaining N2)
        if self.N2 > 0:
            n2_half = self.N2 // 2
            start_idx = self.N1
            
            self.size_particle[start_idx:start_idx + n2_half] = (
                np.random.uniform(0, 1, n2_half) * 
                (self.mid_p_size2 - self.low_p_size2) + 
                self.low_p_size2
            )
            
            area_sum_2 = np.sum(
                self.size_particle[start_idx:start_idx + n2_half] ** 2
            )
            high_p_size2 = (
                2.0 * np.sqrt((self.N2 - area_sum_2) / (self.N2 - n2_half)) - 
                self.mid_p_size2
            )
            
            self.size_particle[start_idx + n2_half:self.N] = (
                np.random.uniform(0, 1, self.N2 - n2_half) * 
                (high_p_size2 - self.mid_p_size2) + 
                self.mid_p_size2
            )
        
        print("Size assignment is done")
        
    def assign_particle_positions(self):
        """Randomly assign non-overlapping initial positions."""
        d_cutoff = 2.80
        
        for i in range(self.N):
            placed = False
            attempts = 0
            max_attempts = 10000
            
            while not placed and attempts < max_attempts:
                # Random position
                self.x[i] = np.random.uniform(0, self.box[0])
                self.y[i] = np.random.uniform(0, self.box[1])
                self.z[i] = 1.25
                
                # Check overlap with existing particles
                if i == 0:
                    placed = True
                else:
                    overlapping = False
                    for j in range(i):
                        dist_cutoff = self.size_particle[i] + self.size_particle[j] + 0.2
                        distance = self._calculate_distance(i, j)
                        if distance <= dist_cutoff:
                            overlapping = True
                            break
                    placed = not overlapping
                
                attempts += 1
            
            if attempts >= max_attempts:
                print(f"Warning: Could not place particle {i} without overlap")
        
        # Calculate statistics
        phi_real = (
            np.sum(self.size_particle ** 3) * (4.0 / 3.0 * np.pi) / 
            (self.box[0] * self.box[1] * self.box[2])
        )
        area_fraction_real = (
            np.sum(self.size_particle ** 2) * np.pi / 
            (self.box[0] * self.box[1])
        )
        
        print("Particle initial positions are assigned")
        print(f"Area fraction = {area_fraction_real:.5e}")
        print(f"Volume fraction = {phi_real:.5e}")
        
        return area_fraction_real
    
    def _calculate_distance(self, i: int, j: int) -> float:
        """Calculate minimum image distance between particles i and j."""
        dx = self.x[i] - self.x[j]
        dy = self.y[i] - self.y[j]
        dz = self.z[i] - self.z[j]
        
        # Apply minimum image convention
        dx = dx - self.box[0] * np.round(dx / self.box[0])
        dy = dy - self.box[1] * np.round(dy / self.box[1])
        dz = dz - self.box[2] * np.round(dz / self.box[2])
        
        return np.sqrt(dx**2 + dy**2 + dz**2)
    
    def solve_reaction_diffusion(self):
        """Solve the reaction-diffusion equations to steady state."""
        print("\nSolving reaction-diffusion equations...")
        start_time = time.time()
        
        self.C1, self.C2, self.Dx_C1, self.Dx_C2, self.Dy_C1, self.Dy_C2, self.alpha2 = (
            self.rd_solver.solve()
        )
        
        elapsed = time.time() - start_time
        print(f"Reaction-diffusion equation is solved ({elapsed:.2f} s)")
        print(f"Alpha (perturbation amplitude) = {self.alpha2:.6f}")
        
    def solve_advection_diffusion(self, area_fraction: float):
        """Solve the advection-diffusion equations for colloidal concentration."""
        print("\nSolving advection-diffusion equations...")
        start_time = time.time()
        
        DNi = (
            self.alpha2 * (
                self.Mob_C1 - 
                self.Mob_C2 * self.eta * (1 + self.A_rd * self.eta) / self.A_rd
            ) / self.Pe
        )
        
        self.phi1, self.phi2 = self.ad_solver.solve(
            self.Dx_C1, self.Dx_C2, self.Dy_C1, self.Dy_C2,
            self.Pe, self.eta, self.alpha2, self.A_rd,
            self.Mob_C1, self.Mob_C2, self.Mob2_C1, self.Mob2_C2,
            self.N, self.N1, area_fraction
        )
        
        elapsed = time.time() - start_time
        print(f"Advection-diffusion equation is solved ({elapsed:.2f} s)")
        
    def save_rd_solutions(self):
        """Save reaction-diffusion and advection-diffusion solutions."""
        # Reaction-diffusion solution
        rd_file = self.output_dir / "Brusselator_SS.txt"
        grad_file = self.output_dir / "grad_Brus_SS.txt"
        colloid_file = self.output_dir / "colloids_vf.txt"
        
        dx = self.size_x / self.nx_rd
        dy = self.size_y / self.ny_rd
        
        with open(rd_file, 'w') as f1, \
             open(grad_file, 'w') as f2, \
             open(colloid_file, 'w') as f3:
            for i in range(self.nx_rd + 1):
                for j in range(self.ny_rd + 1):
                    x = i * dx
                    y = j * dy
                    f1.write(f"{x:20.10e} {y:20.10e} {self.C1[i,j]:20.10e} "
                            f"{self.C2[i,j]:20.10e}\n")
                    f2.write(f"{self.Dx_C1[i,j]:20.10e} {self.Dy_C1[i,j]:20.10e} "
                            f"{self.Dx_C2[i,j]:20.10e} {self.Dy_C2[i,j]:20.10e}\n")
                    f3.write(f"{x:20.10e} {y:20.10e} {self.phi1[i,j]:20.10e} "
                            f"{self.phi2[i,j]:20.10e}\n")
        
        print(f"Saved RD solutions to {rd_file}")
        
    def run_particle_dynamics(self, checkpoint_file: int = 0):
        """Run the particle dynamics simulation."""
        print("\nStarting particle dynamics simulation...")
        
        # Initialize particle system
        self.particle_system.initialize(self.x, self.y, self.z, self.size_particle)
        
        # Initialize velocities
        self.ux[:, :] = 0.0
        self.uy[:, :] = 0.0
        self.uz[:, :] = 0.0
        
        # Save initial state
        self._save_state(0)
        
        # Explicit Euler for first step
        self._explicit_euler_step()
        
        # Calculate initial velocities
        self._calculate_velocities()
        
        # Save first step
        self._save_state(1)
        
        # Store trajectory of particle 0
        self.p1x[0] = self.xorig[0, 1]
        self.p1y[0] = self.yorig[0, 1]
        self.p1x[1] = self.xorig[0, 2]
        self.p1y[1] = self.yorig[0, 2]
        
        # Adams-Bashforth for remaining steps
        start_step = checkpoint_file * 60 + 2 if checkpoint_file > 0 else 2
        
        for step in range(start_step, self.M + 1):
            if step % 100 == 0:
                print(f"Step {step}/{self.M}")
            
            # Time march
            self._adams_bashforth_step(step)
            
            # Calculate velocities
            self._calculate_velocities()
            
            # Calculate statistics
            self._calculate_mean_square(step)
            self._calculate_autocorrelation(step)
            
            # Store trajectory
            self.p1x[step] = self.xorig[0, 2]
            self.p1y[step] = self.yorig[0, 2]
            
            # Save periodically
            if step % self.save_interval == 0:
                ifile = step // self.save_interval
                self._save_state(ifile)
        
        print("Particle dynamics simulation complete")
        
    def _explicit_euler_step(self):
        """First time step using explicit Euler method."""
        # Store initial positions
        self.xorig[:, 0] = self.x
        self.yorig[:, 0] = self.y
        self.zorig[:, 0] = self.z
        self.xorig[:, 1] = self.x
        self.yorig[:, 1] = self.y
        self.zorig[:, 1] = self.z
        
        self.xold = self.x.copy()
        self.yold = self.y.copy()
        self.zold = self.z.copy()
        
        # Update positions
        self.x += self.delta_t * self.ux[:, 1]
        self.y += self.delta_t * self.uy[:, 1]
        self.z += self.delta_t * self.uz[:, 1]
        
        # Apply periodic boundary conditions
        self._apply_periodic_bc()
        
    def _adams_bashforth_step(self, step: int):
        """Adams-Bashforth time stepping."""
        self.xold = self.x.copy()
        self.yold = self.y.copy()
        self.zold = self.z.copy()
        
        # Adams-Bashforth formula
        self.x += 0.5 * self.delta_t * (3.0 * self.ux[:, 1] - self.ux[:, 0])
        self.y += 0.5 * self.delta_t * (3.0 * self.uy[:, 1] - self.uy[:, 0])
        self.z += 0.5 * self.delta_t * (3.0 * self.uz[:, 1] - self.uz[:, 0])
        
        # Update original positions
        self.xorig[:, 1] += (self.x - self.xold)
        self.yorig[:, 1] += (self.y - self.yold)
        self.zorig[:, 1] += (self.z - self.zold)
        
        # Apply periodic boundary conditions
        self._apply_periodic_bc()
        
        # Check and resolve collisions
        self.particle_system.resolve_collisions(
            self.x, self.y, self.z, self.size_particle
        )
        
        # Apply periodic BC again after collision resolution
        self._apply_periodic_bc()
        
    def _apply_periodic_bc(self):
        """Apply periodic boundary conditions."""
        self.x = np.where(self.x > self.box[0], self.x - self.box[0], self.x)
        self.x = np.where(self.x < 0, self.x + self.box[0], self.x)
        
        self.y = np.where(self.y > self.box[1], self.y - self.box[1], self.y)
        self.y = np.where(self.y < 0, self.y + self.box[1], self.y)
        
        self.z = np.where(self.z > self.box[2], self.z - self.box[2], self.z)
        self.z = np.where(self.z < 0, self.z + self.box[2], self.z)
        
    def _calculate_velocities(self):
        """Calculate particle velocities from all forces."""
        # Shift velocity time levels
        self.ux[:, 0] = self.ux[:, 1]
        self.uy[:, 0] = self.uy[:, 1]
        self.uz[:, 0] = self.uz[:, 1]
        
        # Calculate new velocities
        self.ux[:, 1], self.uy[:, 1], self.uz[:, 1] = (
            self.velocity_calc.calculate_velocity(
                self.x, self.y, self.z,
                self.Dx_C1, self.Dy_C1, self.Dx_C2, self.Dy_C2,
                self.nx_rd, self.ny_rd,
                self.Mob_C1, self.Mob_C2, self.Mob2_C1, self.Mob2_C2,
                self.alpha2, self.delta_t, self.a_L0,
                self.size_particle
            )
        )
        
    def _calculate_mean_square(self, step: int):
        """Calculate mean-square displacements."""
        self.ms[0, step] = np.mean((self.xorig[:, 1] - self.xorig[:, 0]) ** 2)
        self.ms[1, step] = np.mean((self.yorig[:, 1] - self.yorig[:, 0]) ** 2)
        self.ms[2, step] = np.mean((self.zorig[:, 1] - self.zorig[:, 0]) ** 2)
        
    def _calculate_autocorrelation(self, step: int):
        """Calculate velocity autocorrelation."""
        if step == 1:
            self.ux0 = self.ux[:, 1].copy()
            self.uy0 = self.uy[:, 1].copy()
            self.uz0 = self.uz[:, 1].copy()
        
        self.auto_vel[0, step] = np.mean(self.ux0 * self.ux[:, 1])
        self.auto_vel[1, step] = np.mean(self.uy0 * self.uy[:, 1])
        self.auto_vel[2, step] = np.mean(self.uz0 * self.uz[:, 1])
        
    def _save_state(self, ifile: int):
        """Save particle positions and velocities."""
        pos_file = self.output_dir / f"pos{ifile:04d}.txt"
        vel_file = self.output_dir / f"vel{ifile:04d}.txt"
        
        np.savetxt(pos_file, np.column_stack([self.x, self.y, self.z]))
        np.savetxt(vel_file, np.column_stack([
            self.ux[:, 1], self.uy[:, 1], self.uz[:, 1]
        ]))
        
        if ifile == 0:
            # Save particle radii once
            radius_file = self.output_dir / "particle_radius.txt"
            np.savetxt(radius_file, self.size_particle)
        
    def save_final_data(self):
        """Save mean-square displacements and autocorrelations."""
        ms_file = self.output_dir / "ms.txt"
        auto_file = self.output_dir / "autocorrelation_vel.txt"
        traj_file = self.output_dir / "par1.txt"
        
        np.savetxt(ms_file, self.ms.T)
        np.savetxt(auto_file, self.auto_vel.T)
        np.savetxt(traj_file, np.column_stack([self.p1x, self.p1y]))
        
        print(f"Saved final data to {self.output_dir}")
        
    def run(self):
        """Run the complete simulation."""
        # Setup
        self.assign_particle_sizes()
        area_fraction = self.assign_particle_positions()
        
        # Solve field equations
        self.solve_reaction_diffusion()
        self.solve_advection_diffusion(area_fraction)
        self.save_rd_solutions()
        
        # Run particle dynamics
        self.run_particle_dynamics()
        
        # Save final data
        self.save_final_data()
        
        print("\n" + "=" * 60)
        print("Simulation complete!")
        print("=" * 60)


if __name__ == "__main__":
    # Example: Run simulation with default parameters
    sim = PolyDispDPBrownianSimulation(
        N=10000,  # Reduced for testing
        N1=5000,
        max_step_rd=100000,  # Reduced for testing
        maxc_step=50000,     # Reduced for testing
        t_final=100.0,       # Reduced for testing
        output_dir="test_output"
    )
    
    sim.run()
